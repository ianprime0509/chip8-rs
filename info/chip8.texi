\input texinfo
@c @include version.texi
@setfilename chip8.info
@settitle Chip-8 @value{VERSION}
@documentencoding UTF-8
@syncodeindex fn cp

@copying
This manual is for Chip-8, version @value{VERSION}.

Copyright @copyright{} 2017--2018 Ian Johnson

@quotation
This manual is distributed under the terms of the MIT license, which can
be found in the `LICENSE' file in the project root or at
@url{https://opensource.org/licenses/MIT}.
@end quotation
@end copying

@titlepage
@title Chip-8
@subtitle Version @value{VERSION}
@author Ian Johnson (@email{ianprime0509@@gmail.com})

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c Print the table of contents at the start.
@contents

@ifnottex
@node Top
@top Chip-8 Reference Guide

This is a reference guide for the Chip-8 interpreter and assembler
developed by Ian Johnson.  It also contains documentation on the Chip-8
and Super-Chip platforms themselves.
@end ifnottex

@menu
* Overview::        Overview of the Chip-8 project.
* The Chip-8 and Super-Chip::      Description of the emulated platforms.
* The emulator::    Documentation for the emulator.
* The assembler::   Documentation for the assembler.
* The disassembler:: Documentation for the disassembler.
* Further reading:: More information about the Chip-8 and Super-Chip.
* Index::           Complete index.
@end menu

@node Overview
@chapter Overview

This manual is the primary documentation for the Chip-8 project, which
consists of the emulator @command{chip8}, the assembler
@command{chip8asm} and the disassembler @command{chip8disasm}.  Since
having an emulator would be useless without knowledge of the original
system, however, we will begin with a description of the Chip-8 and
Super-Chip platforms which this emulator targets.  They are relatively
simple systems, without many of the features that make even the simplest
common platforms (such as the NES) complex, but still provide enough
functionality to create interesting games.

Despite their simplicity, the Chip-8 and Super-Chip are somewhat unique
in the realm of emulators in that most of the information we have about
them comes from secondary sources.  I haven't yet been able to find any
primary sources documenting either platform, perhaps due to their age
and the relative lack of popularity of the original systems.  The
secondary source material is often enough to reconstruct an adequate
description of the systems (@pxref{Further reading}), but there is
occasionally conflicting information and behaviors which some games rely
on (@pxref{Alternative behavior}).  This disunity, and the lack of a
single comprehensive resource detailing the quirks and differences
previously mentioned, is part of my motivation for including such
details in this manual.  That way, it may serve as a useful reference
for other emulator developers, even if they don't make use of the
emulator or assembler that it documents.

@node The Chip-8 and Super-Chip
@chapter The Chip-8 and Super-Chip
@cindex Chip-8
@cindex Super-Chip

The history of the Chip-8 and the Super-Chip is described in some detail
on @url{https://en.wikipedia.org/wiki/CHIP-8,its Wikipedia page}.  To
summarize, it was developed as an interpreted programming language for a
pair of microcomputers in the mid-1970s, and accordingly its
capabilities are rather primitive in comparison to other popular
emulation targets, such as the NES.  This lack of features, however,
makes it a popular target for developing emulators (like this one),
since there are not as many details to consider and the instruction set
is of a manageable size.

When a Chip-8 emulator was developed for the HP-48 series of graphing
calculators, it came with some extensions to the core Chip-8 features,
such as an option for a higher-resolution display mode and several new
operations.  The resulting platform, including these extensions, became
known as the Super-Chip.  The Super-Chip extensions are usually
implemented in modern Chip-8 emulators, since they don't require much
extra work for the developer.

There may be other extensions out there (I remember hearing of an
``Ultra-Chip'' somewhere, but have not been able to find any
documentation), but I don't know of them.  Once the core functionality
is stable, it might be interesting for me to try making some extensions
of my own (in particular, having more than one tone available for the
buzzer would be cool).

@menu
* External hardware::    The display, buzzer and controller.
* Internal hardware::    Registers, memory and more.
@end menu

@node External hardware
@section External hardware
@cindex external hardware
@cindex hardware, external

@menu
* Display::     The displays of the Chip-8 and Super-Chip.
* Buzzer::      Making noise.
* Controller::  Interacting with programs.
@end menu

@node Display
@subsection Display
@cindex display

The original Chip-8 had a single display mode, with only two colors and
a resolution of 64x32.  The Super-Chip retained the monochrome display,
but added a 128x64 ``high-resolution'' display mode (remember that the
Super-Chip was developed for graphing calculators, which don't exactly
have high resolutions to begin with).  On the Super-Chip, the
high-resolution mode coexists with the original Chip-8
``low-resolution'' mode, and programs can either opt-in or explicitly
opt-out using the @code{LOW} and @code{HIGH} instructions
(@pxref{Operation reference}).

What isn't clear from the above information is how exactly these two
modes should interact with each other.  Should it be legal to switch
between them during execution and, if so, what effect should this have?
There doesn't appear to be a ``right answer'' to these questions, since
existing emulators appear to disagree.

To remain compatible with Chip-8 programs which are unaware of the
Super-Chip extensions, @command{chip8} will always start execution in
low-resolution mode.  The underlying display buffer, however, is always
128x64; in low-resolution mode, the upper-left 64x32 rectangle is scaled
to fit the display window.  Thus, it is possible for a program to switch
freely between these two modes during execution with predictable
results.

@node Buzzer
@subsection Buzzer
@cindex buzzer

The sound capabilities of both the original Chip-8 and the Super-Chip
are limited to a single monotone buzzer, which can be programmed using
the @code{ST} (sound timer) register.  As long as @code{ST} is nonzero,
the buzzer will sound; since all Chip-8 timers decrease at a frequency
of 60 Hz, the buzzer can be made to sound for specific lengths of time.
@xref{Registers}.

@node Controller
@subsection Controller
@cindex controller

The controller used with the Chip-8 has sixteen keys, each labeled with
a hexadecimal digit in a 4x4 arrangement.  The arrangement is as
follows:

@multitable .1 .1 .1 .1
@item @kbd{1}
@tab @kbd{2}
@tab @kbd{3}
@tab @kbd{C}
@item @kbd{4}
@tab @kbd{5}
@tab @kbd{6}
@tab @kbd{D}
@item @kbd{7}
@tab @kbd{8}
@tab @kbd{9}
@tab @kbd{E}
@item @kbd{A}
@tab @kbd{0}
@tab @kbd{B}
@tab @kbd{F}
@end multitable

The corresponding arrangement of keys on an HP-48 calculator, which
would have been the typical input method for the Super-Chip, is as
follows:

@multitable .1 .1 .1 .1
@item @kbd{7}
@tab @kbd{8}
@tab @kbd{9}
@tab @kbd{÷}
@item @kbd{4}
@tab @kbd{5}
@tab @kbd{6}
@tab @kbd{×}
@item @kbd{1}
@tab @kbd{2}
@tab @kbd{3}
@tab @kbd{-}
@item @kbd{0}
@tab @kbd{.}
@tab @kbd{SPC}
@tab @kbd{+}
@end multitable

The emulator key mapping (which unfortunately is not yet configurable)
is as follows:

@multitable .1 .1 .1 .1
@item @kbd{1}
@tab @kbd{2}
@tab @kbd{3}
@tab @kbd{4}
@item @kbd{q}
@tab @kbd{w}
@tab @kbd{e}
@tab @kbd{r}
@item @kbd{a}
@tab @kbd{s}
@tab @kbd{d}
@tab @kbd{f}
@item @kbd{z}
@tab @kbd{x}
@tab @kbd{c}
@tab @kbd{v}
@end multitable

@node Internal hardware
@section Internal hardware
@cindex internal hardware
@cindex hardware, internal

@menu
* Registers::                  The Chip-8 registers.
* Memory and program storage:: How programs are stored in memory.
* Graphics storage::           How sprites are stored in memory.
@end menu

@node Registers
@subsection Registers
@cindex register

The Chip-8 has sixteen general-purpose registers, labeled @code{V0}
through @code{VF}, each of which stores a single unsigned 8-bit value.
Register @code{VF} is used by many operations to signal certain
conditions (such as collisions when drawing sprites, @pxref{Operation
reference}).  There is no stack, and reading values from particular
memory locations is cumbersome, so registers are really the only
reliable means of passing data between subroutines.

There is a special register, labeled @code{I}, which holds an unsigned
16-bit value and is used by many operations as storage for an address in
memory.  For example, the @code{DRW} operation uses the value of
@code{I} as the address of the sprite to draw at the given coordinates.

There are two timer registers, @code{DT} and @code{ST}, each of which
holds an unsigned 8-bit value and decreases to 0 at a rate of 60 Hz once
it is set.  Register @code{DT} is known as the ``delay timer''; it has
no predefined function, and can be used anywhere a timer is needed.
Register @code{ST} is the ``sound timer'', and will cause the buzzer to
sound for as long as it holds a nonzero value (@pxref{Buzzer}).

The final register is the program counter, which stores the address of
the currently executing instruction.  It is not accessible to programs
except through the @code{JP}, @code{CALL} and @code{RET} instructions.
For use with the @code{CALL} and @code{RET} instructions, a stack of
program counter values (the @dfn{call stack}) is maintained internally;
@command{chip8} has an unbounded call stack, but other emulators may
have restrictions.

@node Memory and program storage
@subsection Memory and program storage
@cindex memory
@cindex program
@cindex storage, of programs

The Chip-8 and Super-Chip both provide 4096 bytes of addressable memory,
512 bytes of which are reserved for the interpreter.  Although modern
emulators no longer store the interpreter itself in these lower 512
bytes, it is still used as a reliable location to store the built-in
sprite font characters, since programs know not to use it
(@pxref{Graphics storage}).

When the emulator is directed to run a program, it loads the entire
program into memory starting at address @samp{0x200} (just past the 512
bytes of reserved memory) and sets the program counter to this value.
Every Chip-8 instruction is two bytes wide and appears in the program
MSB (most significant byte) first; that is, the Chip-8 is big-endian.
The two bytes of each instruction are also known as the instruction's
@dfn{opcode}.  For a list of all valid opcodes, @pxref{List of
operations}.

It should be noted that all instructions must be aligned on two-byte
boundaries; it is an error to attempt to jump to a misaligned memory
address, to prevent reading bogus instructions.

@node Graphics storage
@subsection Graphics storage
@cindex storage, of graphics

The original Chip-8 supported drawing simple images (or @dfn{sprites})
of exactly eight pixels in width and between one and fifteen (inclusive)
pixels in height using the @code{DRW} operation.  Each row of a sprite
would be represented by a single byte, with the bits in the byte
indicating whether the corresponding pixel should be set or cleared (the
most significant bit being the left-most pixel in the row).  Thus, the
third operand to @code{DRW}, which specifies the number of bytes that
the sprite occupies in memory, is also the sprite's height in pixels.
The sprite is drawn from top to bottom, so that the first byte read
represents the top-most row of the sprite on screen.

The Super-Chip, supporting a higher display resolution, extended the
@code{DRW} operation with support for 16x16 pixel sprites.  By
specifying @samp{0} as the third operand to @code{DRW}, the Super-Chip
reads sixteen pairs of bytes from the indicated memory location (namely,
the value of register @code{I}; @pxref{List of operations}), drawing the
sprite from left to right, top to bottom.  That is, the first byte read
gives the left-most eight pixels of the sprite's top row, the second
byte gives the right-most eight pixels of the same row, and so on,
continuing downwards.

Sprites are drawn to screen using the bitwise @code{XOR} operation.
This means that drawing the same sprite at the same location twice will
have no net effect on the display.  It will, however, have an effect on
the code: if any collision is encountered when drawing a sprite (that
is, if any pixels are turned off during the operation), the @code{VF}
register is set to @samp{1}.  If there is no collision, the @code{VF}
register is set to @samp{0}.

The Chip-8 also comes with a simple bitmap font for the hexadecimal
digits @samp{0} through @samp{F}.  Each font sprite is 4x5 pixels, and
is stored in memory below the 512-byte program boundary.  The memory
location of the sprite (for drawing) can be loaded into the @code{I}
register using the @code{LD H, @var{vx}} instruction, where the lower
four bits of @var{vx} are taken as the desired hexadecimal digit.  The
Super-Chip adds a higher-resolution font with the same character set,
which coexists alongside the original Chip-8 font; each
higher-resolution font character is 8x10 pixels, and can be accessed
using the @code{LD HF, @var{vx}} instruction.

A note about timing: every @code{DRW} operation is delayed until the
start of the next clock cycle.  By default, the clock runs at 60 Hz, the
same frequency as the @code{DT} and @code{ST} timer registers
(@pxref{Registers}).  Some emulators appear to do their timing
differently, but doing it this way produces good results with all the
games I've tried.

@node The emulator
@chapter The emulator
@cindex emulator

This package comes with a Chip-8/Super-Chip emulator, invoked as
@command{chip8}, which aims to correctly emulate as many Chip-8 and
Super-Chip games as possible while offering user configuration where
applicable.  Currently, all the Chip-8 games I have tested work without
issue, while some Super-Chip games need more work.

Since both the original Chip-8 and Super-Chip were interpreters running
on other machines rather than deedicated hardware, the terms
``emulator'' and ``interpreter'' will be used interchangeably when
referring to @command{chip8}.

@menu
* Invoking chip8::      Using the emulator.
@end menu

@node Invoking chip8
@section Invoking @command{chip8}
@cindex @command{chip8} (command)

The command @command{chip8} must be invoked with the name of a program
file to run, unless either the @option{--help} or @option{--version}
option is used.  The following options are understood:

@table @option
@item --frequency=@var{freq}
Set the internal game timer to @var{freq} Hz; default 60.  This affects
the behavior of the @code{ST} and @code{DT} registers as well as the
delay between @code{DRW} operations.

@item --shift-quirks
@itemx -q
Enable shift quirks mode, which uses the alternative, two-operand
interpretation of the operations @code{SHR} and @code{SHL} rather than
the default, one-operand interpretation. @xref{Alternative behavior}.

@item --scale=@var{scale}
@itemx -s @var{scale}
Set the game display scale; default 6.  In the Super-Chip's
high-resolution mode, each pixel of the 128x64 grid will be displayed as
@var{scale} square pixels on the user's display.  This is doubled in
low-resolution mode, resulting in the same user-facing window
size. @xref{Display}.

@item --tone=@var{tone}
@itemx -t @var{tone}
Set the game buzzer tone, in Hz; default 440.  This is the tone that
will sound (using a square wave) when the sound timer @code{ST} is
nonzero. @xref{Buzzer}.

@item --verbose
@itemx -v
Increase output verbosity.  You can pass this option multiple times to
show more output; currently, passing this option more than twice has no
further effect.

@item --volume=@var{volume}
Set the game buzzer volume, as a value from 0 to 100; default 10.

@item --help
@itemx -h
Show a description of usage and available options, and exit.

@item --version
@itemx -V
Show program version information, and exit.
@end table

@node The assembler
@chapter The assembler
@cindex assembler

@menu
* Invoking chip8asm::   Using the assembler.
* Syntax::              Overview of assembler syntax.
* Operations::          The various operations used as instructions.
@end menu

@node Invoking chip8asm
@section Invoking @command{chip8asm}
@cindex invoking assembler
@cindex assembler, invocation

The command @command{chip8asm} must be invoked with the name of a source
file to assemble, unless either the @option{--help} or
@option{--version} option is used.  The following options are
understood:

@table @option
@item --output=@var{output}
@itemx -o @var{output}
Sets the output file name.  The default is to take the input file name
and change the extension (if any) to @samp{.bin}.

@item --shift-quirks
@itemx -q
Enable shift quirks mode, which uses the alternative, two-operand
interpretation of the operations @code{SHR} and @code{SHL} rather than
the default, one-operand interpretation. @xref{Alternative behavior}.

@item --verbose
@itemx -v
Increase output verbosity.  You can pass this option multiple times to
show more output; currently, passing this option more than twice has no
further effect.

@item --help
@itemx -h
Show a description of usage and available options, and exit.

@item --version
@itemx -V
Show program version information, and exit.
@end table


@node Syntax
@section Syntax
@cindex syntax
@cindex assembler syntax

@node Line format
@subsection Line format
@cindex line format
@cindex assembler line format

The syntax used in the assembler is similar to that used in the popular
CHIPPER assembler.  The assembly input is processed one line at a time,
where each line may consist of a label and/or an instruction.  Blank
lines are also allowed, for readability.  A semicolon, @samp{;}, may be
used to begin a comment; the rest of the line following the semicolon
will be ignored.

A label consists of an identifier followed by a colon, @samp{:}, and
must be the first element on its line (optionally preceded by
whitespace).  An identifier may start with an underscore or alphabetic
character, and may additionally contain the digits 0--9 after the
initial character.  It is not possible to define two different labels to
refer to the same instruction, or to define two labels with the same
identifer.  Label names are case-sensitive, so @code{label1} will be
treated as a separate label from @code{LABEL1}.

An instruction consists of an operation and, depending on the operation,
a comma-separated list of operands (@pxref{Operations} for a list of
operations).  The name of the operation is not case-sensitive, so
@code{DRAW} is processed the same as @code{draw} and @code{dRaW}.
Depending on the operation, each operand of an instruction may be either
the name of a register or an expression (@pxref{Expressions}).  If a
particular operand could be interpreted either as a register name which
would be valid in its position or as an expression, the register
interpretation will be chosen.  Thus, the instruction @code{ADD V1, V2}
will always be interpreted as ``add register @code{V2} to register
@code{V1}'', and not ``add the value of the label @code{V2} to register
@code{V1}'', even if @code{V2} happens to have been defined as a label
name.

@node Expressions
@subsection Expressions
@cindex expression
@cindex assembler expression

The treatment of expressions in the assembler is similar to that used in
most programming languages, such as C: they are written in infix
notation, and label names may be used as identifiers to represent their
values.  The meanings and precedences of the operators should also be
mostly familiar to those experienced in other programming languages,
particularly C.

Since the Chip-8 is fundamentally a 16-bit machine, all quantities in
expressions are treated as 16-bit unsigned numbers.  If an expression
results in a value which is outside the range of a 16-bit unsigned
quantity, it will be converted to one by taking its residue modulo
@math{2^16}.  This is equivalent to assuming a two's-complement
representation of signed numbers.  In cases where an expression is used
in an operand which is narrower than 16 bits (for example, the @code{JP}
operation takes a single 12-bit operand, @xref{Operations}), the result
of the expression is truncated to fit (in the example, the lowest 12
bits are kept and the highest 4 discarded).

There are two unary operators, both of which are applied to the left of
their operand: these are the unary negation operator @code{-} and the
bitwise NOT operator @code{~}.  They have a higher precedence than any
binary operator.

The binary operators, in decreasing order of precedence, are given
below; operators at the same level of precedence will be evaluated
left-to-right (e.g. they are left-associative).

@enumerate
@item
@code{*} for multiplication, @code{/} for division and @code{%} for
modulus.

@item
@code{+} for addition and @code{-} for subtraction.

@item
@code{>} and @code{<}, which are the logical right and left shifts,
respectively.  The assembler does not provide arithmetic shift
operators, since numeric quantities are always treated as unsigned.

@item
@code{&} for the bitwise AND operation.

@item
@code{^} for the bitwise XOR operation.

@item
@code{|} for the bitwise OR operation.
@end enumerate

@node Operations
@section Operations
@cindex operation
@cindex assembler operation

When speaking of operations in the assembler, we distinguish between
true operations and ``pseudo-operations''.  A true operation is one that
corresponds directly to a Chip-8 or Super-Chip instruction, such as
@code{ADD}, while a pseudo-operation does not.

@menu
* Operation reference::         Reference for ``true'' operations.
* Pseudo-operations::       Reference for pseudo-operations.
@end menu

@node Operation reference
@subsection Operation reference
@cindex true operation
@cindex operation, true

The operations described in this section form a complete description of
the Chip-8/Super-Chip instruction set.  Every instruction used by the
Chip-8 or Super-Chip is represented by a two-byte opcode,
@pxref{Internal hardware}.

@menu
* Operation notation::  Conventions for writing operations and opcodes.
* List of operations:: List of all operations with their opcodes.
* Alternative behavior:: Different treatment by other interpreters.
@end menu

@node Operation notation
@subsubsection Operation notation
@cindex operation notation
@cindex notation, operation

For consistency and readability, we will use certain conventions to
denote the operands taken by each operation.  For operands which must be
a certain literal value, this value is used (e.g. the @code{DT} in
@code{LD DT, Vx}).  For register operands, we use @var{vx} and @var{vy}
as placeholders for the register names.  For other quantities, we use
@var{addr} for 12-bit addresses, @var{byte} for 8-bit quantities and
@var{nibble} for 4-bit quantities.

The opcodes corresponding to each instruction (operation with operands)
follow a parallel convention.  Each opcode consists of four alphanumeric
characters, corresponding to the four digits in its hexadecimal
representation.  A hexadecimal digit (with letters written in uppercase)
in a particular position indicates that that same digit is present in
the opcode, while lowercase letters indicate that the value of some
operand should be substituted in their position according to the table
below.

@table @samp
@item x
The index of register @var{vx}.

@item y
The index of register @var{vy}.

@item nnn
The 12-bit value of the address @var{addr}.

@item kk
The 8-bit value of the byte @var{byte}.

@item n
The 4-bit value of the nibble @var{nibble}.
@end table

For example, the instruction @code{DRW @var{vx}, @var{vy}, @var{nibble}}
has opcode @samp{Dxyn} according to this convention, indicating that the
concrete instruction @code{DRW V1, VA, 5} has opcode @samp{D1A5}.

@node List of operations
@subsubsection List of operations
@cindex operation reference

The descriptions of the operations given here reflect the behavior of
the included emulator, @command{chip8}, and are intended to reflect as
accurately as possible the conventional understanding of each operation.
However, owing to the diversity of emulators in existence, there may be
alternate behaviors for some operations (@pxref{Alternative behavior}).
It is also possible that I've made a mistake somewhere, especially with
some of the less conventional operations; if you find such a mistake,
please let me know so that I can fix it.

@deffn Operation SCD nibble
This operation scrolls the screen down by @var{nibble} pixels.  It is
only available on the Super-Chip, and its opcode is @samp{00Cn}.
@end deffn

@deffn Operation CLS
This operation clears the entire display.  Its opcode is @samp{00E0}.
@end deffn

@deffn Operation RET
This operation returns from a subroutine; it is an error to use
@code{RET} without a corresponding preceding @code{CALL}.  Its opcode is
@samp{00EE}.
@end deffn

@deffn Operation SCR
This operation scrolls the screen right by 4 pixels.  It is only
available on the Super-Chip, and its opcode is @samp{00FB}.
@end deffn

@deffn Operation SCL
This operation scrolls the screen left by 4 pixels.  It is only
available on the Super-Chip, and its opcode is @samp{00FC}.
@end deffn

@deffn Operation EXIT
This operation signals to the interpreter to exit immediately.  It is
only available on the Super-Chip, and its opcode is @samp{00FD}.
@end deffn

@deffn Operation LOW
This operation switches the display to low-resolution mode
(@pxref{External hardware}).  It is only available on the Super-Chip,
and its opcode is @samp{00FE}.
@end deffn

@deffn Operation HIGH
This operation switches the display to high-resolution mode
(@pxref{External hardware}).  It is only available on the Super-Chip,
and its opcode is @samp{00FF}.
@end deffn

@deffn Operation JP addr
This operation sets the program counter to @var{addr}.  It is an error
to jump to an address which is not aligned on a 2-byte boundary.  Its
opcode is @samp{1nnn}.
@end deffn

@deffn Operation CALL addr
This operation calls the subroutine at @var{addr}; that is, it sets the
program counter to @var{addr} and pushes the original program counter to
the call stack so that it can be returned to using @code{RET}.  It is an
error to call a subroutine which is not aligned on a 2-byte boundary.
Its opcode is @samp{2nnn}.
@end deffn

@deffn Operation SE vx, byte
This operation skips the next instruction if the value of @var{vx} is
equal to @var{byte}.  Its opcode is @samp{3xkk}.
@end deffn

@deffn Operation SNE vx, byte
This operation skips the next instruction if the value of @var{vx} is
not equal to @var{byte}.  Its opcode is @samp{4xkk}.
@end deffn

@deffn Operation SE vx, vy
This operation skips the next instruction if the values of @var{vx} and
@var{vy} are equal.  Its opcode is @samp{5xy0}.
@end deffn

@deffn Operation LD vx, byte
This operation loads @var{byte} into register @var{vx}.  Its opcode is
@samp{6xkk}.
@end deffn

@deffn Operation ADD vx, byte
This operation adds @var{byte} to the value of register @var{vx},
storing the result (modulo 256) in @var{vx}.  Register @code{VF} is set
to 1 if a carry occurred (that is, if the true sum was greater than or
equal to 256), or 0 otherwise.  Its opcode is @samp{7xkk}.
@end deffn

@deffn Operation LD vx, vy
This operation loads the value of @var{vy} into @var{vx}.  Its opcode is
@samp{8xy0}.
@end deffn

@deffn Operation OR vx, vy
This operation computes the bitwise OR of @var{vx} and @var{vy}, storing
the result in @var{vx}.  Its opcode is @samp{8xy1}.
@end deffn

@deffn Operation AND vx, vy
This operation computes the bitwise AND of @var{vx} and @var{vy},
storing the result in @var{vx}.  Its opcode is @samp{8xy2}.
@end deffn

@deffn Operation XOR vx, vy
This operation computes the bitwise XOR of @var{vx} and @var{vy},
storing the result in @var{vx}.  Its opcode is @samp{8xy3}.
@end deffn

@deffn Operation ADD vx, vy
This operation adds the value of @var{vy} to that of @var{vx}, storing
the result (modulo 256) in @var{vx}.  Register @code{VF} is set to 1 if
a carry occurred, or 0 otherwise.  Its opcode is @samp{8xy4}.
@end deffn

@deffn Operation SUB vx, vy
This operation subtracts the value of @var{vy} from that of @var{vx},
storing the result (modulo 256) in @var{vx}.  Register @code{VF} is set
to 0 if a borrow occurred (that is, if the true value of the difference
would be negative under signed arithmetic), or to 1 otherwise.  Its
opcode is @samp{8xy5}.
@end deffn

@deffn Operation SHR vx
This operation performs a logical right shift on the value of @var{vx},
storing the result in @var{vx}.  The original least significant bit of
@var{vx} is stored in register @code{VF}.  Its opcode is @samp{8x06}.
@end deffn

@deffn Operation SUBN vx, vy
This operation subtracts the value of @var{vx} from that of @var{vx},
storing the result in @var{vx}.  Register @code{VF} is set to 0 if a
borrow occurred, or to 1 otherwise.  Its opcode is @samp{8xy7}.
@end deffn

@deffn Operation SHL vx
This operation performs a left shift on the value of @var{vx}, storing
the result in @var{vx}.  The original most significant bit of @var{vx}
is stored in register @code{VF}.  Its opcode is @samp{8x0E}.
@end deffn

@deffn Operation SNE vx, vy
This operation skips the next instruction if the values of @var{vx} and
@var{vy} are not equal.  Its opcode is @samp{9xy0}.
@end deffn

@deffn Operation LD I, addr
This operation loads @var{addr} into register @code{I}.  Its opcode is
@samp{Annn}.
@end deffn

@deffn Operation JP V0, addr
This operation computes the sum @var{addr} and the value of @code{V0},
and jumps to the resulting address.  It is an error if the computed
address is not aligned on a 2-byte boundary.  Its opcode is @samp{Bnnn}.
@end deffn

@deffn Operation RND vx, byte
This operation generates a random byte and performs a logical AND with
@var{byte}, storing the resulting value in @var{vx}.  Its opcode is
@samp{Cxkk}.
@end deffn

@deffn Operation DRW vx, vy, nibble
This operation loads a sprite @var{nibble} bytes long starting at the
memory location indicated by the value of register @code{I}.  The sprite
is drawn at position (@var{vx}, @var{vy}); register @code{VF} is set to
1 if a collision occurs, or to 0 otherwise.  On the Super-Chip only,
@var{nibble} may be 0, in which case a 16x16-pixel sprite will be read.
For more information about how sprites are loaded and drawn,
@pxref{Graphics storage}.

Its opcode is @samp{Dxyn}.
@end deffn

@deffn Operation SKP vx
This operation takes the name of a key from the lower four bits of the
value of @var{vx}, and skips the next instruction if that key is
currently being pressed.  For more information about keys,
@pxref{Controller}.  Its opcode is @samp{Ex9E}.
@end deffn

@deffn Operation SKNP vx
This operation takes the number of a key from the lower four bits of the
value of @var{vx}, and skips the next instruction if that key is not
currently being pressed.  Its opcode is @samp{ExA1}.
@end deffn

@deffn Operation LD vx, DT
This operation loads the value of the delay timer (register @code{DT})
into @var{vx}.  Its opcode is @samp{Fx07}.
@end deffn

@deffn Operation LD vx, K
This operation waits for a key press, and then stores the number of the
key in @var{vx}.  If several keys are pressed at once, priority goes to
the one with the lower number.  After a key press is detected and
processed, the same key will not be detected by further operations
unless it is released and pressed again.

Its opcode is @samp{Fx0A}.
@end deffn

@deffn Operation LD DT, vx
This operation loads the value of @var{vx} into the delay timer
(register @code{DT}).  Its opcode is @samp{Fx15}.
@end deffn

@deffn Operation LD ST, vx
This operation loads the value of @var{vx} into the sound timer
(register @code{ST}).  Its opcode is @samp{Fx18}.
@end deffn

@deffn Operation ADD I, vx
This operation adds the value of @var{vx} to register @code{I}, storing
the result in @code{I}.  If the result is too large to fit in the 16-bit
register @code{I}, the behavior is undefined.  Its opcode is
@samp{Fx1E}.
@end deffn

@deffn Operation LD F, vx
This operation treats the lower four bits of @var{vx} as a hexadecimal
digit, and stores in register @code{I} the location in memory of the
low-resolution font sprite for that digit.  For more information about
these pre-defined sprites, @pxref{Graphics storage}.  Its opcode is
@samp{Fx29}.
@end deffn

@deffn Operation LD HF, vx
This operation is similar to @code{LD F, @var{vx}}, but the address
stored in register @code{I} is the location of a high-definition font
sprite for the desired digit.  It is only available on the Super-Chip,
and its opcode is @samp{Fx30}.
@end deffn

@deffn Operation LD B, vx
This operation stores the three-digit binary-coded decimal
representation of the value of @var{vx} in the three bytes starting at
the value of register @code{I} (with the most significant digit first).
For example, if the value of @var{vx} is @samp{123} in decimal, then the
three bytes stored will be @samp{1}, @samp{2} and @samp{3}, in that
order.

Its opcode is @samp{Fx33}.
@end deffn

@deffn Operation LD [I], vx
This operation takes the values of registers @code{V0} through @var{vx}
(inclusive) and stores them sequentially in memory starting at the
address stored in register @code{I}.  Its opcode is @samp{Fx55}.
@end deffn

@deffn Operation LD vx, [I]
This operation copies bytes sequentially into the registers @code{V0}
through @var{vx} (inclusive) starting at the address stored in register
@code{I}.  Thus, it is the inverse operation to @code{LD [I], @var{vx}}.
Its opcode is @samp{Fx65}.
@end deffn

@deffn Operation LD R, vx
This operation has something to do with the registers on an HP-48
calculator, but I don't really know and it seems nobody else does
either.  It is only available on the Super-Chip, and its opcode is
@samp{Fx75}.
@end deffn

@deffn Operation LD vx, R
This operation should be the inverse to @code{LD R, @var{vx}}.  It is
only available on the Super-Chip, and its opcode is @samp{Fx85}.
@end deffn

@node Alternative behavior
@subsubsection Alternative behavior
@cindex alternative behavior (of operations)

Some interpreters do not behave exactly as described in the operation
reference, and some games are developed which rely on these alternative
behaviors.  This section documents all the alternative behavior I have
encountered so far.

The @code{SHL} and @code{SHR} operations have the following variant
forms, accepting two operands rather than the usual one.  The
interpreter (@pxref{Invoking chip8}) and assembler (@pxref{Invoking
chip8asm}) both accept a flag instructing them to use these variant
forms.

@deffn {Alternate operation} SHR vx, vy
This operation performs a logical right shift on the value of @var{vy},
storing the result in @var{vx}.  The original least significant bit of
@var{vy} is stored in register @code{VF}.  Its opcode is @samp{8xy6}.
@end deffn

@deffn {Alternate operation} SHL vx, vy
This operation performs a logical left shift on the value of @var{vy},
storing the result in @var{vx}.  The original most significant bit of
@var{vy} is stored in register @code{VF}.  Its opcode is @samp{8xyE}.
@end deffn

There are also alternative behaviors for operations which copy register
data to and from memory (that is, the operations involving @code{[I]}).
The interpreter accepts a flag instructing it to use these alternative
behaviors (they make no difference to the assembler).

@deffn {Alternate operation} LD [I], vx
This operation is the same as @code{LD [I], @var{vx}}, but after
execution the value of register @code{I} is set to the memory address
directly after that of the stored values.
@end deffn

@deffn {Alternate operation} LD vx, [I]
This operation is the same as @code{LD @var{vx}, [I]}, but after
execution the value of register @code{I} is set to the memory address
directly after that of the loaded values.
@end deffn

@node Pseudo-operations
@subsection Pseudo-operations
@cindex pseudo-operation
@cindex operation, pseudo-

The first important class of pseudo-operations are those which provide
support for conditional assembly, that is, emitting different assembly
instructions based on a assemble-time condition.

@deffn Pseudo-operation IFDEF label
This pseudo-operation begins a conditional assembly block.  If
@var{label} is defined when @code{IFDEF} is processed, then all
instructions up to the matching @code{ELSE} or @code{ENDIF} are
processed, and any instructions following the @code{ELSE} (if present)
until the matching @code{ENDIF} are ignored.  If @var{label} is
undefined, then the assembler ignores all instructions until the
matching @code{ELSE} or @code{ENDIF}, instead processing those which
follow @code{ELSE} (if present).
@end deffn

@deffn Pseudo-operation IFNDEF label
This pseudo-operation is the opposite of @code{IFDEF}: if @var{label} is
undefined, the conditional assembly is processed until @code{ELSE} and
then ignored until @code{ENDIF}, and vice versa if @var{label} is
defined.
@end deffn

@deffn Pseudo-operation ELSE
This pseudo-operation marks the beginning of the assembly instructions
to be processed if the corresponding conditional was false, or to be
ignored if the corresponding conditional was true.  It may be used at
most once within a block of conditional assembly.
@end deffn

@deffn Pseudo-operation ENDIF
This pseudo-operation marks the end of a block of conditional assembly.
@end deffn

The second important class of pseudo-operations are those which modify
the value of labels.  The most general of these is the special @code{=}
pseudo-operation, which is used with the syntax @code{@var{label} =
@var{expression}}, setting the value of @var{label} to the result of
@var{expression}.

@deffn Pseudo-operation DEFINE label
This is equivalent to @code{@var{label} = 0}, and indicates that
@var{label} will be used not for its value, but as a flag for
conditional compilation using @code{IFDEF} or @code{IFNDEF}.
@end deffn

The third important class of pseudo-operations are those which insert
literal bytes into the assembled output.

@deffn Pseudo-operation DW expression
This pseudo-operation evaluates @var{expression} and inserts the result
(treated as a big-endian 16-bit unsigned integer) into the assembled
output.  For example, @code{DW #1234} will insert the bytes @code{#12}
and @code{#34} (in that order) into the assembled output.
@end deffn

@deffn Pseudo-operation DB expression
This pseudo-operation evaluates @var{expression} and inserts the result
(treated as an 8-bit unsigned integer) into the assembled output (only
the least significant 8 bits of @var{expression} are kept,
@pxref{Expressions}).  An operation following @code{DB} will be aligned
to the next 2-byte boundary to ensure that no misaligned operations are
produced; however, this alignement will not occur for pseudo-operations
such as @code{DW} and @code{DB}.
@end deffn

Finally, the last class of pseudo-operations (which currently has only
one rather useless member) are those which give a directive to the
assembler to affect the way it processes further instructions.

@deffn Pseudo-operation OPTION name
This pseudo-operation (currently) does nothing.  Eventually, different
values of @var{name} may be used to enable or disable certain assembly
modes or features.  For example, perhaps @code{OPTION SHQUIRKS} could be
used to enable shift quirks, removing the need for the @samp{-q} flag,
@pxref{Invoking chip8asm}.
@end deffn

@node The disassembler
@chapter The disassembler

Since this project includes an assembler, it's not too much of a stretch
to expect it to have a disassembler as well.  The disassembler included
with this project, @command{chip8disasm}, aims to be a reliable tool for
use with the vast majority of Chip-8 programs.

@menu
* Invoking chip8disasm::    Using the disassembler.
* Output format::           The standard disassembler output format.
@end menu

@node Invoking chip8disasm
@section Invoking @command{chip8disasm}

The command @command{chip8disasm} must be invoked with the name of a
program file to disassemble, unless either the @option{--help} or
@option{--version} option is used; currently, reading the program from
the standard input is not supported.  The following options are
understood:

@table @option
@item --output=@var{output}
@itemx -o @var{output}
Set the output file name.  The default is to print to the standard
output (i.e. the terminal).

@item --shift-quirks
@itemx -q
Enable shift quirks mode, which uses the alternative, two-operand
interpretation of the operations @code{SHR} and @code{SHL} rather than
the default, one-operand interpretation. @xref{Alternative behavior}.

@item --verbose
@itemx -v
Increase output verbosity.  You can pass this option multiple times to
show more output; currently, passing this option more than twice has no
further effect.

@item --help
@itemx -h
Show a description of usage and available options, and exit.

@item --version
@itemx -V
Show program version information, and exit.
@end table

@node Output format
@section Output format

The disassembler output format is compatible with the input format used
in the assembler.  That is, if you disassemble a Chip-8 program with
@command{chip8disasm} and then re-assemble it with @command{chip8asm},
you should get a file identical to the original.  There are some
exceptions to this: for example, programs that use the alternative
behavior for shift instructions (@pxref{Alternative behavior}) will need
to be both disassembled and assembled with the @option{--shift-quirks}
flag (@pxref{Invoking chip8disasm}).

@menu
* Detecting code versus data::  Basic control flow analysis.
* Labels in output::            How the disassembler uses labels.
@end menu

@node Detecting code versus data
@subsection Detecting code versus data

One complication which the disassembler addresses is the lack of
distinction between code and data in Chip-8 assembly.  Thus, a naïve
disassembler that attempts to decode each 2-byte word as an instruction
will run into problems and report many invalid instructions (which
aren't really instructions at all, but data).  @command{chip8disasm}
solves this problem using a simple form of ``control flow analysis'',
which analyzes the program structure to detect which sections are
reachable (code) and which are not (data).

The current implementation should work for the vast majority of programs
in existence (and has worked for all the ones I've tried), but isn't
perfect.  The most notable omission is that the @code{JP V0, @var{addr}}
instruction is not fully supported, so that the locations it jumps to
will not be marked as reachable.  Of course, by using the lack of
code/data distinction to your advantage, you could devise all sorts of
programs to intentionally make control flow analysis impossible, like
explicitly synthesizing instructions in memory during execution.  But
why would you do something like that, anyways?

@node Labels in output
@subsection Labels in output

To make reading the disassembled code easier, the disassembler will
replace explicit address operands with labels.  The labels are named
predictably: a label that points to the address @samp{#2A8} will have
the name @samp{L0A8}.  That is, the label name is formed from the
address minus 512 bytes (the first 512 bytes of memory being reserved
for the interpreter; @pxref{Memory and program storage}).

@node Further reading
@chapter Further reading
@cindex further reading

There are several good resources on the Web for Chip-8 information. For
a Chip-8 instruction/opcode reference, see
@url{http://devernay.free.fr/hacks/chip8/C8TECH10.HTM,Cowgod's Chip-8
Technical Reference}; it also lists the opcodes for Super-Chip
instructions, but does not give their descriptions.  For a collection of
many Chip-8 and Super-Chip games, as well as an emulator for DOS, see
@url{http://www.pong-story.com/chip8/,David Winter's Chip-8 page}.
There is also some documentation included with his emulator, which gives
some more background on the Chip-8, including details about some variant
implementations.  There is also some information here:
@url{http://chip8.sourceforge.net/chip8-1.1.pdf}.

@node Index
@unnumbered Index
@cindex index

@printindex cp

@bye
